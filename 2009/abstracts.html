<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>VII Jornadas de Ciencias de la Computaci&oacute;n</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<link rel="stylesheet" href="main.css" />
</head>
<body>
<div id="container">
	<div id="header">
		<div id="left">
			<a href="http://www.fceia.unr.edu.ar/lcc/"><img src="logo-lcc.jpg" width="150" alt="Licenciatura en Ciencias de la Computacion" /></a>
		</div>
		<div id="center">
			<h1 class="center">JCC VII</h1>
  			<h2 class="center">7mas. Jornadas de Ciencias de la Computaci&oacute;n</h2>
  			<h3 class="center">23 y 24 de Octubre del 2009<br />Rosario, Argentina</h3>
		</div>
		<div id="right">
			&nbsp;
		</div>
	</div>
	<div id="content">
		<div class="title">Abstracts</div>
    	
		<div class="charla">
			<div class="atitle">Introducci&oacute;n a los conjuntos fractales</div>
			<p class="abstracts">
				<label class="disertante">Andrea Silvetti</label> [Universidad Nacional del Sur]<br /><br />
				Desde su irrupci&oacute;n a fines de la d&eacute;cada de 1970, los conjuntos fractales constituyen un tema de creciente inter&eacute;s cient&iacute;fico en matem&aacute;tica, f&iacute;sica, computaci&oacute;n, y en la mayor&iacute;a de las ciencias aplicadas. Su gran difusi&oacute;n y aplicabilidad interdisciplinaria se debe a varias razones, entre las cuales podemos contar su universalidad como fen&oacute;meno natural, sus interesantes propiedades matem&aacute;ticas, su relativamente sencillo tratamiento computacional, y la sugestiva belleza de sus representaciones gr&aacute;ficas. La geometr&iacute;a fractal se convirti&oacute; r&aacute;pidamente en un lenguaje adecuado para describir las complejas formas naturales, en contraposici&oacute;n con la geometr&iacute;a Eucl&iacute;dea, m&aacute;s amena para las idealizaciones matem&aacute;ticas. Al mismo tiempo, su descripci&oacute;n matem&aacute;tica se basa en la formulaci&oacute;n iterativa o recursiva, en vez de la definici&oacute;n axiom&aacute;tica caracter&iacute;stica de los objetos matem&aacute;ticos tradicionales. Estos dos factores hacen de los objetos fractales un recurso sobresaliente a la hora de simular fen&oacute;menos naturales de todo tipo.<br />
			El objetivo de esta charla consiste en presentar una introducci&oacute;n a los fundamentos matem&aacute;ticos y algor&iacute;tmicos de los conjuntos fractales, y algunas de las aplicaciones m&aacute;s importantes de estos conjuntos en la simulaci&oacute;n de fen&oacute;menos naturales, la computaci&oacute;n gr&aacute;fica y el procesamiento digital de im&aacute;genes.<br />
			Temario:<br />
			Simetr&iacute;a a escala y la medici&oacute;n de objetos complejos. Fractales cl&aacute;sicos y definiciones topol&oacute;gicas. Conjuntos de Cantor, von Koch y Peano. Dimensi&oacute;n no entera. Dimensi&oacute;n fractal de conjuntos matem&aacute;ticos y de fen&oacute;menos naturales. Caos determin&iacute;stico y fractales. Conjuntos de Julia. La universalidad del caos. Conjunto de Mandelbrot. Algunos formalismos relacionados: aut&oacute;matas celulares y gram&aacute;ticas L. Fractales no determin&iacute;sticos. M&eacute;todos espaciales y frecuenciales para la determinaci&oacute;n de fractales no determin&iacute;sticos. Sistemas de funci&oacute;n iterada (IFS). Descripci&oacute;n de im&aacute;genes por simetr&iacute;a a escala. Teoremas de punto fijo y el teorema del collage. Aplicaciones de los IFS en Computaci&oacute;n Gr&aacute;fica. S&iacute;ntesis de fen&oacute;menos naturales. Procesamiento y compresi&oacute;n fractal de im&aacute;genes.
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Writing a kernel from scratch</div>
			<p class="abstracts">
				<label class="disertante">Duilio Protti</label><br /><br />
				In JCC 2008 we have written both a virtual machine launcher and a small, dummy kernel to run inside it. This approach serves to learn about low level programming and processor manipulation. However, the end result is not a real OS kernel suitable to boot on a real PC, but it only works inside the virtual machine created by us. This year, we will develop a real OS kernel from scratch, following the guidelines of the Carnegie Mellon 410 course on Operating Systems but with slight modifications to avoid the need to use a Simics simulator. The end result should be a real OS kernel image capable of booting our PC from persistent media like i.e. a floppy disk or hard disk.
			</p> 
		</div>
		
		<div class="charla">
			<div class="atitle">Criptograf&iacute;a y verificaci&oacute;n de programas probabil&iacute;sticos</div>
			<p class="abstracts">
				<label class="disertante">Santiago Zanella B&eacute;guelin</label> [INRIA Sophia Antipolis - M&eacute;diterran&eacute;e y MSR-INRIA Joint Centre]<br /><br />
				Demostrar la seguridad de un sistema criptogr&aacute;fico es en general una tarea compleja que requiere razonar sobre campos tan diversos como probabilidad, complejidad computacional y &aacute;lgebra. No son raros los casos de pruebas que se han considerado correctas por años hasta que alguien puso en evidencia errores de razonamiento. Por esta raz&oacute;n, y para facilitar la verificaci&oacute;n de pruebas de seguridad, la comunidad criptogr&aacute;fica ha adoptado una manera unificada de estructurar las pruebas como secuencias de "juegos": experimentos probabil&iacute;sticos en presencia de un atacante desconocido pero con poder computacional limitado. Construir una prueba basada en juegos es un proceso creativo que no puede automatizarse en su totalidad. Por otro lado, verificar una prueba basada en juegos, tal como se la presenta en la mayor&iacute;a de las publicaciones, requiere de un esfuerzo considerable. En esta charla veremos como usando t&eacute;cnicas de verificaci&oacute;n formal de programas, podemos obtener pruebas de seguridad basadas en juegos que son correctas por construcci&oacute;n y cuya verificaci&oacute;n puede automatizarse completamente. La esencia de nuestra propuesta es representar los experimentos definidos por juegos como programas en un lenguaje de programaci&oacute;n probabil&iacute;stico con una sem&aacute;ntica formal. Veremos como muchos de los razonamientos que aparecen en pruebas de seguridad en criptograf&iacute;a se reducen a la demostraci&oacute;n de propiedades sobre un programa o de relaciones entre pares de programas. Veremos, adem&aacute;s, como muchos pasos en una prueba pueden mecanizarse usando un asistente de prueba (Coq) y t&eacute;cnicas de optimizaci&oacute;n de programas com&uacute;nmente usadas en compiladores (e.g. dead code elimination, constant folding, inline expansion, copy propagation, code reordering).
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Breve Introducci&oacute;n al Procesamiento del Habla</div>
			<p class="abstracts">
				<label class="disertante">Agust&iacute;n Gravano</label> [Universidad de Buenos Aires]<br /><br />
				Debido a su gran complejidad, los lenguajes naturales (castellano, japon&eacute;s, guaran&iacute;, etc.) presentan serias dificultades para la creaci&oacute;n de sistemas capaces de manipularlos autom&aacute;ticamente. En particular,  el procesamiento del habla --disciplina relativamente joven-- todav&iacute;a acumula m&aacute;s cuentas pendientes que logros concretos. Sin embargo, en a&ntilde;os recientes han comenzado a aparecer aplicaciones con resultados aceptables en dominios acotados, fruto de d&eacute;cadas de investigaci&oacute;n, y buen incentivo para continuar trabajando. En esta charla describir&eacute; algunos temas centrales del &aacute;rea, incluyendo el reconocimiento autom&aacute;tico del habla, la s&iacute;ntesis del habla y el modelado de la prosodia (entonaci&oacute;n, ritmo, etc.).
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Virtualizaci&oacute;n: Arquitectura, pr&aacute;ctica y ataques.</div>
			<p class="abstracts">
				<label class="disertante">Fernando Russ &amp; Pedro Varangot</label> [Core Labs]<br /><br />
				Virtualizaci&oacute;n es uno de los grupos de tecnologias m&aacute;s en boga de los &uacute;ltimos tiempos.  Abstraer los recursos de una computadora para simular otras no es una tarea sencilla a priori y presenta una serie de desafios t&eacute;cnico mas que importantes. Durante esta charla se buscan introducir los conceptos fundamentales para entender estas tecnolog&iacute;as, para luego analizarlas desde el punto de vista de la seguridad inform&aacute;tica haciendo incapie en el punto de vista del atacante.
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Una extensi&oacute;n de shortcut fusion con m&uacute;ltiples aplicaciones.</div>
			<p class="abstracts">
				<label class="disertante">Alberto Pardo</label> [Universidad de la Rep&uacute;blica]<br /><br />
				En programaci&oacute;n funcional, los programas consisten de un conjunto de definiciones de funciones que reciben ciertas estructuras de datos como entrada y retornan otras como salida. Dichas funciones se suelen construir como la composici&oacute;n de funciones relativamente simples y sencillas de escribir. Los programas as&iacute; definidos tienden a ser m&aacute;s modulares, pero su eficiencia puede verse afectada en forma significativa por el uso sistem&aacute;tico de la composici&oacute;n de funciones. Cada composici&oacute;n implica la construcci&oacute;n de una estructura de datos intermedia cuyos valores deben ser alojados en memoria, recorridos y finalmente descartados, requiriendo por lo tanto tiempo adicional de procesamiento, espacio de memoria para alojar nodos de la estructura y frecuentes llamadas al "garbage collector".<br />
				Existen t&eacute;cnicas de transformaci&oacute;n de programas cuyo objetivo es la eliminaci&oacute;n de aquellas estructuras intermedias que no jueguen un rol esencial en la computaci&oacute;n. Esto es, se desea transformar el c&oacute;digo original a uno equivalente en donde se intenta sustituir las composiciones de funciones por definiciones que combinan de forma adecuada los c&oacute;digos de las funciones involucradas. A estas t&eacute;cnicas de transformaci&oacute;n de programas se las conoce como fusi&oacute;n o deforestaci&oacute;n.<br />
				En esta charla hablaremos de una t&eacute;cnica de fusi&oacute;n, conocida como "shortcut fusion", y presentaremos una extensi&oacute;n a la misma, mostrando sus aplicaciones. En particular, gracias a esta extensi&oacute;n ha sido posible definir la fusi&oacute;n de programas con efectos colaterales (programas mon&aacute;dicos) y la derivaci&oacute;n de programas circulares (tanto puramente funcionales como con efectos).
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Verificaci&oacute;n de propiedades de seguridad con an&aacute;lisis est&aacute;tico liviano</div>
			<p class="abstracts">
				<label class="disertante">Marcelo Arroyo</label> [Universidad Nacional de R&iacute;o Cuarto]<br /><br />
				Las aplicaciones actuales tienen requisitos no funcionales como tolerancia a ataques, robustez de uso y mantener confidencialidad de datos. Los sistemas tienen miles de l&iacute;neas de c&oacute;digo y la inspecci&oacute;n manual de c&oacute;digo se hace pr&aacute;cticamente imposible. El testing es muy dificultoso de dise&ntilde;ar e implementar para descubrir problemas de seguridad. Los m&eacute;todos de verficaci&oacute;n formales no escalan para manejar grandes vol&uacute;menes de c&oacute;digo. Las t&eacute;cnicas de an&aacute;lisis est&aacute;tico liviano permiten descubrir indicios de problemas haciendo an&aacute;lisis de c&oacute;digo fuente. Estas t&eacute;cnicas escalan bien aunque generalmente son conservativas, es decir que pueden producir alertas falsas (falsos positivos). Se analizar&aacute; su ambiente de aplicaci&oacute;n, tipos de errores que pueden encontrarse, algunas herramientas disponibles y las t&eacute;cnicas utilizadas.	
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">Implementaci&oacute;n del modelo HPC colaborativo aplicable a problemas de bio-inform&aacute;tica</div>
			<p class="abstracts">
				<label class="disertante">Luc&iacute;a Laur&iacute;a &amp; Ing. Rafael Garabato</label> [Universidad Cat&oacute;lica de C&oacute;rdoba - Intel]<br /><br />
				En esta presentaci&oacute;n se mostrar&aacute; un modelo colaborativo para c&oacute;mputos de altas prestaciones (HPC) que permite distribuir programas de naturaleza recursiva. Cuando se trabaja con programas dise&ntilde;ados para brindar soluciones que requieren de  procesamiento masivo de datos, se hace evidente la necesidad de contar con equipo especialmente preparado para este tipo de problemas. El enfoque tomado en nuestro proyecto es la utilizaci&oacute;n de un cluster de computadoras para c&oacute;mputos de altas prestaciones, utilizando las herramientas de software de Intel. Con esta tecnolog&iacute;a se obtienen las ventajas de tener un sistema con bajo costo, escalabilidad al poder insertar f&aacute;cilmente nuevos nodos y, fundamentalmente, reducci&oacute;n del tiempo de procesamiento por la distribuci&oacute;n de tareas.
			</p>
		</div>
		
		<div class="charla">
			<div class="atitle">M&eacute;todos Formales para el An&aacute;lisis de Software</div>
			<p class="abstracts">
				<label class="disertante">Araceli Acosta &amp; Nazareno Matias Aguirre</label> [Universidad Nacional de C&oacute;rdoba]<br /><br />
				Los m&eacute;todos formales, cuya aplicación se limit&oacute; durante alg&uacute;n tiempo a porciones de sistemas cr&iacute;ticos de software/hardware, han ganado popularidad y sus campos de aplicaci&oacute;n se han ampliado. En este &eacute;xito de los m&eacute;todos formales, la disponibilidad de herramientas de apoyo, y en particular herramientas para la aplicaci&oacute;n de diferentes tareas de an&aacute;lisis, ha jugado un rol importante.  En esta charla daremos una breve descripci&oacute;n de varios m&eacute;todos formales para el an&aacute;lisis de software, poniendo &eacute;nfasis en el uso de herramientas. Los m&eacute;todos formales discutidos incluir&aacute;n m&eacute;todos formales deductivos, cuyas herramientas son en general asistidas, y m&eacute;todos formales que ofrecen mecanismos algor&iacute;tmicos de an&aacute;lisis, como es el caso del modelchecking.
			</p>
		</div>
		
		<!-- <p class="center">
			<a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10-blue" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a><br />
		</p> -->
	</div>
</div>
</body>
</html>
